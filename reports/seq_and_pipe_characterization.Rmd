---
title: "Sequence Data and Pipeline Characterization"
author: "Nate Olson"
date: '`r Sys.Date()`'
output:
  bookdown::pdf_document2: 
    toc: FALSE
---

```{r seqPipeCharSetup, warning=FALSE, message=FALSE, echo = FALSE}
#library(ProjectTemplate)
#load.project() 

library(iNEXT)

ps_list <- list.files("data/phyloseq_objects", full.names = TRUE) %>% 
    set_names(str_replace(basename(.), "_ps.rds", "")) %>% 
    map(readRDS)

library(ggpubr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r seqCharError}
error_plot <- ggplot(phix_error_df) +
    geom_point(aes(x = base_position, y = errorrate, color = ds), alpha = 0.01) +
    geom_smooth(aes(x = base_position, y = errorrate, color = ds, linetype = read)) +
    theme_bw() +
    labs(x = "Amplicon Base Position", y = "PhiX Error Rate", color = "Dataset") +
    scale_color_manual(values=run_colors)+
    theme(legend.direction = "horizontal", legend.position = "bottom", legend.box = "vertical")
```

```{r seqCharCount}
r1_seq_char_df <- seq_char_df %>%
    filter(read_dir == "R1") %>%
    left_join(mgtstMetadata) %>%
    mutate(seq_run = as.character(seq_run))
r1_ntc <- r1_seq_char_df %>% filter(biosample_id == "NTC") 

n_read_plot <- r1_seq_char_df %>% filter(biosample_id != "NTC") %>%
    ggplot() + 
        geom_boxplot(aes(x = seq_lab, y = read, color = seq_run)) + 
        geom_point(data = r1_ntc, aes(x = seq_lab, y = read, color = seq_run), 
                   shape = 21,
                   position = position_jitterdodge(jitter.width = 0.25)) + 
        scale_y_log10() + 
        theme_bw() + labs(x = "Sequencing Lab", 
                          y = "Library Size", 
                          color = "Sequencing Run") +
        theme(legend.position = "bottom")+scale_color_manual(values=run_colors)
```

 
```{r covFit}
## TODO move to munge
qual_df <- seq_qual_comparisons %>% 
    mutate(read_dir = paste0(read_dir, "_qual")) %>% 
    select(-sd_quality, -cov_quality) %>% 
    spread(read_dir, mean_quality) %>% 
    separate(replicate, c("biosample_id","t_fctr","seq_run_id"), remove = FALSE,extra = "merge")

tech_art_df <- seq_char_comparisons %>% 
    select(replicate,  pipe, normalization, metric, cov_num_reads, cov_total_abu) %>% 
    left_join(qual_df)
fit2 <- lme4::lmer(cov_total_abu ~ seq_run_id + (1 | pipe / biosample_id / t_fctr), 
                   data = tech_art_df)

confint_dat <- confint(fit2)
mod_betas <- fit2@beta
cov_est <- data_frame(run_id = c("jhu_run1","jhu_run2","nist_run1","nist_run2"),
                      est = c(mod_betas[1], 
                              mod_betas[1] + mod_betas[2],
                              mod_betas[1] + mod_betas[3],
                              mod_betas[1] + mod_betas[4]))
                    
fit_est_df <- as.data.frame(confint_dat) %>% 
    rownames_to_column(var = "run_id") %>% 
    filter(!grepl("sig", run_id)) %>% 
    gather("conf_int","est", -run_id) %>% 
    spread(run_id, est) %>%
    rename(jhu_run1 = `(Intercept)`) %>%
    gather("run_id","est", -conf_int, -jhu_run1) %>% 
    mutate(est = jhu_run1 + est) %>% 
    mutate(run_id = str_replace(run_id, "seq_run_id","")) %>%
    spread(run_id, est) %>% 
    gather("run_id","est", -conf_int) %>% 
    mutate(conf_int = if_else(conf_int == "2.5 %", "lci","uci")) %>% 
    spread(conf_int, est) %>% 
    left_join(cov_est) %>% 
    mutate(seq_run_id = str_replace(run_id, "_run",""))

cov_plot <- ggplot(fit_est_df) + 
    geom_pointrange(aes(x = seq_run_id, y = est, ymin = lci, ymax = uci, color=seq_run_id)) + 
    labs(x = "Sequencing Run", y = "Total Abundance COV") +
    theme_bw() + scale_color_manual(values=run_colors) + theme(legend.position="none")
```

```{r qualFit}
seq_qual_dat <- seq_char_df %>% 
    left_join(mgtstMetadata) %>% 
    filter(biosample_id != "NTC") %>% 
    mutate(seq_run_id = paste0(seq_lab, seq_run))

## See 2018-02-15 for linear model results - all statistically significantly different 

seq_qual_plot <- seq_qual_dat %>% 
    ggplot() + 
    geom_boxplot(aes(x = seq_run_id, y = quality, color = read_dir))  + theme_bw() + 
    labs(x = "Sequencing Run", y = "Mode Read Base Quality Score", color = "Read Direction") + 
    theme(legend.position = "bottom")+scale_color_manual(values=c("black", "darkgray"))
```


```{r seqCharPlot, fig.cap = "A. Coeffient of variation in total abundance by sequencing run estimate and 95\\% confidence interval obtined using a mixed effects linear model. B. PhiX error rate relative to 16S rRNA amplicon base position for initial and the four sequencing runs. C. Distribution of mode read quality score by sequencing run. ", fig.height=4, fig.width=10}
ggarrange(cov_plot, error_plot, seq_qual_plot, labels = "AUTO", ncol = 3)
```


```{r pipeCharTbl, echo = FALSE, message = FALSE, warning = FALSE}
pipe_char_summary <- pipe_char_df %>%
    unnest() %>% 
    left_join(mgtstMetadata) %>% 
    filter(biosample_id != "NTC") %>% 
    group_by(pipe, n_taxa, n_samples, num_singletons, sparsity) %>% 
    summarise(total_abu_med = round(median(total_abu),0),
              total_abu_max = round(max(total_abu),0),
              total_abu_min = round(min(total_abu),0), 
              pass_rate_med = round(median(pass_rate),2),
              pass_rate_max = round(max(pass_rate),2),
              pass_rate_min = round(min(pass_rate),2)) %>% 
    mutate(total_abu_summary = paste0(total_abu_med, " (", 
                                      total_abu_max, "-", total_abu_min,")")) %>% 
    mutate(pass_rate_summary = paste0(pass_rate_med, " (",
                                      pass_rate_max, "-", pass_rate_min,")")) %>% 
    mutate(sparsity = round(sparsity, 3)) %>% 
    select(-total_abu_med, -total_abu_max, -total_abu_min,
           -pass_rate_med, -pass_rate_max, -pass_rate_min)

pipe_char_summary %>% 
    select(pipe, n_taxa, num_singletons, n_samples,  sparsity, 
           total_abu_summary, pass_rate_summary) %>% 
      dplyr::rename(Pipelines = pipe, Features = n_taxa, 
                    Singletons = num_singletons,
                    Samples = n_samples, 
                    Sparsity = sparsity, 
                    `Total Abundance` = total_abu_summary, 
                    `Pass Rate` = pass_rate_summary) %>% 
      knitr::kable(caption = "Summary statistics for the different bioinformatic pipelines. Four pipelines, de novo, open reference, closed reference, and deblur (sequence inference), used the sample sequence pre-processing methods. DADA2 is a denoising sequence inference pipeline and mothur is a de-novo clustering pipeline. No template controls were excluded from summary statistics. Sparsity is the proportion of 0's in the count table. Features is the total number of OTUs (QIIME and mothur) or SVs (DADA2) in the count. Singletons is the total number of OTUs comprised of a single read in a single sample. Sample coverage is the median and range (minimum - maximum) per sample total feature abundance. Filter rate is the proportion of reads that were removed while processing the sequencing data for each bioinformatic pipeline.", booktabs = TRUE)
```


```{r abuDist}
get_rad_df <- function(ps, sample_name) {
    x_abu <- prune_samples(sample_name, ps) %>%
        {prune_taxa(taxa_sums(.) > 0, .)} %>%
        otu_table() %>%
        as.vector() %>%
        sort(decreasing = TRUE)
    
    data_frame(rank = 1:length(x_abu), abund = x_abu)
}

rad_df <- ps_list %>% map_df(get_rad_df, "nist_run1_1-A1", .id = "pipe")
```


```{r abuDistPlot, eval=FALSE, fig.cap = "Species abundance curves for example sample."}
rad_df %>% mutate(pipe = str_replace(pipe, "_ps.rds","")) %>% 
ggplot() + geom_point(aes(x = rank, y = abund)) + 
    scale_y_log10() + 
    theme_bw() + 
    labs(x = "Feature Rank", y = "Abundance") + 
    facet_wrap(~pipe, scales = "free_x")
```


```{r rareCurve}
ps_iNEXT <- function(ps){
    sample_set <- c("nist_run1_2-A10","nist_run2_2-A10",
                    "jhu_run1_2-A10","jhu_run2_2-A10")
    count_tbl <- prune_samples(sample_set, ps)  %>%
        {prune_taxa(taxa_sums(.) > 0, .)} %>%
        otu_table() 
    
    if (!taxa_are_rows(ps)) {
        count_tbl <- t(count_tbl)
    } 

    count_df <- as.data.frame(count_tbl)
    
    iNEXT::iNEXT(count_df)
}

rare_plot_df <- tibble(ps_obj = ps_list) %>% 
    add_column(pipe = names(ps_list)) %>% 
    mutate(inext_dat = map(ps_obj, ps_iNEXT),
           rare_plot = map2(inext_dat, pipe, ~{iNEXT::ggiNEXT(.x) + theme_bw() + ggtitle(.y)+
                   scale_color_manual(values=run_colors2)})) %>%
    select(-ps_obj, -inext_dat)
```

```{r rarePlot, fig.cap = "Rarefaction curves for example sample across pipelines and sequencing runs.", fig.height=6, fig.width=8} 
ggarrange(plotlist = rare_plot_df$rare_plot,labels = "AUTO", legend = "right",common.legend = TRUE, nrow=3, ncol=2)
```

```{r prevDF}
## Code modified from Callahan F1000
get_prevdf <- function(ps){
    prevdf <- apply(X = otu_table(ps), 
                MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
                FUN = function(x){sum(x > 0)})

    # Add taxonomy and total read counts to this data.frame
    data.frame(Prevalence = prevdf, 
               TotalAbundance = taxa_sums(ps), 
               tax_table(ps)) %>% 
        mutate(PrevFrac = Prevalence / nsamples(ps))
}


pipe_prev_df <- ps_list %>% map_df(get_prevdf, .id = "pipe")
```


```{r prevPlot, eval=FALSE, fig.cap="Feature prevalence distribution by pipeline. A) 2D histogram with the relationship between feature total abundance across all samples and sequencing runs"}
prev_facet <- ggplot(pipe_prev_df, aes(TotalAbundance, PrevFrac)) +
    geom_hex() +
    scale_x_log10() + 
    facet_wrap(~pipe) + 
    labs(x = "Total Abundance", y = "Prevalence [Frac. Samples]") + 
    theme_bw()

prev_smooth <- ggplot(pipe_prev_df, aes(TotalAbundance, PrevFrac)) + 
    geom_smooth(aes(color = pipe)) + 
    scale_x_log10() +
    labs(x = "Total Abundance", y = "Prevalence [Frac. Samples]") + 
    theme_bw()
ggarrange(prev_facet, prev_smooth, labels = "AUTO")
```

Bioinformatic pipelines and normalization methods are used reduce the impact of noise in marker gene sequencing data due to sequencing errors and differences in the library size between samples. 
Sequencing data for the two-sample titration dataset was obtained from four replicate sequencing runs with different sequence quality and library size variability (Fig. \@ref(fig:seqCharPlot), _Supplemental DADA2 qual plot_). The sequence data was processed using six different bioinformatic pipelines, DADA2, mothur, Deblur, and QIIME - _de novo_, open-reference, closed-reference. 
The NIST runs had but greater variabiltiy in library size (Fig. \@ref(fig:seqCharPlot)A). 
Good separation between sample and no template control library size for JHU but not NIST samples.  
However, total abundance is lower for samples compared to no template controls for most sequencing runs and samples. 
Though a few no template controls have values within the sample range.  (see pipe characterization total abundance and pass rate plots). 
After processing the sequence data with the six bioinformatic pipelines the coefficint of variation total abundance between PCR replicates was lower for JHU and NIST run 2 compared to the first runs (Fig. \@ref(fig:seqCharPlot)B).  
The first JHU run had higher PhiX error rates compared to the other sequencing runs especially for the reverse reads (Fig. \@ref(fig:seqCharPlot)C). 
The read base quality was lower for the reverse read than the forward reads, the reverse read quality score was higher for the two nist runs compared to the JHU runs (Fig. \@ref(fig:seqCharPlot)C). 
The forward reads from NIST run 1 had the best read quality score followed by JHU run 2.  
JHU run 2 had low read quality and high total abundance COV, NIST run 1 had higher quality and total abundance COV, NIST and JHU second runs had lower COV, but JHU had lower read 2 quality and NIST run had lower forward read quality. 
The differences in sequence quality and total abundance variabiltiy between sequencing runs allows us to evaluate how well bioinformatic pipelines and normalization methods handle low quality reads and variability between samples.


The six bioinformatic pipelines evaluated employ different pre-processing, clustering, and quality filtering methods, as a result the features and count tables generated by the pipelines exhibit different characteristics in terms of the number of features, total abundance, and proportion of sequences passing quality control (Table \@ref(tab:pipeCharTbl)). 
Rarefaction curves are in ecology to determine how well a community has been sampled [@Gotelli2001,@Chao2014]. 
Measurement methods prone to errors, such as marker-gene sequencing, will never reach the asympotote if errors are not appropriately accounted for in sample processing [@Chiu2016]. 
Sequence inference methods have lower species diversity estimates  and reach asympotote, whereas _de novo_, open-reference, and closed-reference methods do not (Fig. \@ref(fig:rarePlot)). 
Based on the rarefaction curve slopes the QIIME _de novo_ pipeline had the highest rate of artifacts, due to not filtering singletons. 
The sequence inference methods, DADA2 and Deblur plateau around the same level. 
However, DADA2 asymptotes were inconsistent across sequencing runs, indicating artificial plateaus for the lower throughput and lower quality runs. 
Mothur and Deblur rarefaction curves were consistent across sequencing runs. 
The QIIME open reference, closed reference, and de novo rarefaction curves were influenced by both sequence quality and library size. 
    

<!-- Excluding for now not sure contributes to narrative -->
<!-- * Prevalence (Fig. \@ref(fig:prevPlot))   -->
<!--     - DADA2 slope starts later than other pipelines   -->
<!--     - mothur starts to plateu ...  -->
<!--     - qiime de-novo, open and closed ref hump?   -->
<!-- Species abundance curves are fundamentally different between pipelines, indicating that the features generated using represent different biological units and therefore should be interpreted as such (Fig. \@ref(fig:abuDistPlot)) -->


