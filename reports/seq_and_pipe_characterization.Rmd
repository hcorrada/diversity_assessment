---
title: "Sequence Data and Pipeline Characterization"
author: "Nate Olson"
date: '`r Sys.Date()`'
output:
  bookdown::pdf_document2: 
    toc: FALSE
---

```{r seqPipeCharSetup, warning=FALSE, message=FALSE, echo = FALSE}
library(ProjectTemplate)
load.project() 

ps_list <- list.files("data/phyloseq_objects", full.names = TRUE) %>% 
    set_names(str_replace(basename(.), "_ps.rds", "")) %>% 
    map(readRDS)

library(ggpubr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r seqCharError}
error_plot <- ggplot(phix_error_df) +
    geom_point(aes(x = base_position, y = errorrate, color = ds), alpha = 0.01) +
    geom_smooth(aes(x = base_position, y = errorrate, color = ds, linetype = read)) +
    theme_bw() +
    labs(x = "Amplicon Base Position", y = "PhiX Error Rate", color = "Dataset") 
```

```{r seqCharCount}
r1_seq_char_df <- seq_char_df %>%
    filter(read_dir == "R1") %>%
    left_join(mgtstMetadata) %>%
    mutate(seq_run = as.character(seq_run))
r1_ntc <- r1_seq_char_df %>% filter(biosample_id == "NTC") 

n_read_plot <- r1_seq_char_df %>% filter(biosample_id != "NTC") %>%
    ggplot() + 
        geom_boxplot(aes(x = seq_lab, y = read, color = seq_run)) + 
        geom_point(data = r1_ntc, aes(x = seq_lab, y = read, color = seq_run), 
                   shape = 21,
                   position = position_jitterdodge(jitter.width = 0.25)) + 
        scale_y_log10() + 
        theme_bw() + labs(x = "Sequencing Lab", 
                          y = "Library Size", 
                          color = "Sequencing Run") +
        theme(legend.position = "bottom")
```

 

```{r seqCharPlot, fig.cap = "A. PhiX error rate relative to 16S rRNA amplicon base position for initial and the four sequencing runs. B. Distribution in the number of reads per barcoded sample (Library Size) by sequncing laboratory and sequencing run. Negative control library size is indicated by hollow points. Negative controls were not included in the boxplots."}
ggarrange(error_plot, n_read_plot)
```


```{r pipeCharTbl, echo = FALSE, message = FALSE, warning = FALSE}
pipe_char_summary <- pipe_char_df %>%
    unnest() %>% 
    left_join(mgtstMetadata) %>% 
    filter(biosample_id != "NTC") %>% 
    group_by(pipe, n_taxa, n_samples, sparsity) %>% 
    summarise(total_abu_med = round(median(total_abu),0),
              total_abu_max = round(max(total_abu),0),
              total_abu_min = round(min(total_abu),0), 
              pass_rate_med = round(median(pass_rate),2),
              pass_rate_max = round(max(pass_rate),2),
              pass_rate_min = round(min(pass_rate),2)) %>% 
    mutate(total_abu_summary = paste0(total_abu_med, " (", 
                                      total_abu_max, "-", total_abu_min,")")) %>% 
    mutate(pass_rate_summary = paste0(pass_rate_med, " (",
                                      pass_rate_max, "-", pass_rate_min,")")) %>% 
    mutate(sparsity = round(sparsity, 3)) %>% 
    select(-total_abu_med, -total_abu_max, -total_abu_min,
           -pass_rate_med, -pass_rate_max, -pass_rate_min)

pipe_char_summary %>% 
    select(pipe, n_taxa, n_samples, sparsity, total_abu_summary, pass_rate_summary) %>% 
      dplyr::rename(Pipelines = pipe, Features = n_taxa, Samples = n_samples, 
                    Sparsity = sparsity, 
                    `Total Abundance` = total_abu_summary, 
                    `Pass Rate` = pass_rate_summary) %>% 
      knitr::kable(caption = "Summary statistics for the different bioinformatic pipelines. Four pipelines, de novo, open reference, closed reference, and deblur (sequence inference), used the sample sequence pre-processing methods. DADA2 is a denoising sequence inference pipeline and mothur is a de-novo clustering pipeline. No template controls were excluded from summary statistics. Sparsity is the proportion of 0's in the count table. Features is the total number of OTUs (QIIME and mothur) or SVs (DADA2) in the count. Sample coverage is the median and range (minimum - maximum) per sample total feature abundance. Filter rate is the proportion of reads that were removed while processing the sequencing data for each bioinformatic pipeline.", booktabs = TRUE)
```


```{r abuDist}
get_rad_df <- function(ps, sample_name) {
    x_abu <- prune_samples(sample_name, ps) %>%
        {prune_taxa(taxa_sums(.) > 0, .)} %>%
        otu_table() %>%
        as.vector() %>%
        sort(decreasing = TRUE)
    
    data_frame(rank = 1:length(x_abu), abund = x_abu)
}

rad_df <- ps_list %>% map_df(get_rad_df, "nist_run1_1-A1", .id = "pipe")
```


```{r abuDistPlot, eval=FALSE, fig.cap = "Species abundance curves for example sample."}
rad_df %>% mutate(pipe = str_replace(pipe, "_ps.rds","")) %>% 
ggplot() + geom_point(aes(x = rank, y = abund)) + 
    scale_y_log10() + 
    theme_bw() + 
    labs(x = "Feature Rank", y = "Abundance") + 
    facet_wrap(~pipe, scales = "free_x")
```


```{r rareCurve}
ps_iNEXT <- function(ps){
    sample_set <- c("nist_run1_2-A10","nist_run2_2-A10",
                    "jhu_run1_2-A10","jhu_run2_2-A10")
    count_tbl <- prune_samples(sample_set, ps)  %>%
        {prune_taxa(taxa_sums(.) > 0, .)} %>%
        otu_table() 
    
    if (!taxa_are_rows(ps)) {
        count_tbl <- t(count_tbl)
    } 

    count_df <- as.data.frame(count_tbl)
    
    iNEXT::iNEXT(count_df)
}

rare_plot_df <- tibble(ps_obj = ps_list) %>% 
    add_column(pipe = names(ps_list)) %>% 
    mutate(inext_dat = map(ps_obj, ps_iNEXT),
           rare_plot = map2(inext_dat, pipe, ~{iNEXT::ggiNEXT(.x) + theme_bw() + ggtitle(.y)})) %>%
    select(-ps_obj, -inext_dat)
```

```{r rarePlot, fig.cap = "Rarefaction curves for example sample across pipelines and sequencing runs."} 
ggarrange(plotlist = rare_plot_df$rare_plot,labels = "AUTO",legend = "bottom",common.legend = TRUE)
```

```{r prevDF}
## Code modified from Callahan F1000
get_prevdf <- function(ps){
    prevdf <- apply(X = otu_table(ps), 
                MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
                FUN = function(x){sum(x > 0)})

    # Add taxonomy and total read counts to this data.frame
    data.frame(Prevalence = prevdf, 
               TotalAbundance = taxa_sums(ps), 
               tax_table(ps)) %>% 
        mutate(PrevFrac = Prevalence / nsamples(ps))
}


pipe_prev_df <- ps_list %>% map_df(get_prevdf, .id = "pipe")
```


```{r prevPlot, eval=FALSE, fig.cap="Feature prevalence distribution by pipeline. A) 2D histogram with the relationship between feature total abundance across all samples and sequencing runs"}
prev_facet <- ggplot(pipe_prev_df, aes(TotalAbundance, PrevFrac)) +
    geom_hex() +
    scale_x_log10() + 
    facet_wrap(~pipe) + 
    labs(x = "Total Abundance", y = "Prevalence [Frac. Samples]") + 
    theme_bw()

prev_smooth <- ggplot(pipe_prev_df, aes(TotalAbundance, PrevFrac)) + 
    geom_smooth(aes(color = pipe)) + 
    scale_x_log10() +
    labs(x = "Total Abundance", y = "Prevalence [Frac. Samples]") + 
    theme_bw()
ggarrange(prev_facet, prev_smooth, labels = "AUTO")
```

Bioinformatic pipelines and normalization methods are used reduce the impact of noise in marker gene sequencing data due to sequencing errors and differences in the library size between samples. 
Sequencing data for the two-sample titration dataset was obtained from four replicate sequencing runs with different sequence quality and library size variability (Fig. \@ref(fig:seqCharPlot), _Supplemental DADA2 qual plot_). 
The first JHU run had higher PhiX error rates compared to the other sequencing runs especially for the reverse reads (Fig. \@ref(fig:seqCharPlot)A). 
NIST runs had lower error rates compared to the JHU runs but greater variabiltiy in library size (Fig. \@ref(fig:seqCharPlot)B). 
Good separation between sample and no template control library size for JHU but not NIST samples.  
However, total abundance is lower for samples compared to no template controls for most sequencing runs and samples. 
Though a few no template controls have values within the sample range.  (see pipe characterization total abundance and pass rate plots).  


The sequence data was processed using six different bioinformatic pipelines, DADA2, mothur, Deblur, and QIIME - _de novo_, open-reference, closed-reference. 
Pipelines employ different pre-processing, clustering, and quality filtering methods, as a result the features and count tables generated by the pipelines exhibit different characteristics in terms of the number of features, total abundance, and proportion of sequences passing quality control (Table \@ref(tab:pipeCharTbl)). 
Rarefaction curves are in ecology to determine how well a community has been sampled (__REF__). 
Measurement methods prone to errors, such as marker-gene sequencing, will never reach the asympotote if errors are not appropriately accounted for in sample processing (__REF Chao__). 
Sequence inference methods have lower species diversity estimates  and reach asympotote, whereas _de novo_, open-reference, and closed-reference methods do not (Fig. \@ref(fig:rarePlot)).  

- De novo highest rate of artifacts (due to lack of singleton filtering)  
    - De novo steepest slope in rarefaction curves  
- DADA2 and Deblur plateu around the same level  
- DADA2 inconsistent across sequencing runs, artificial plateau  
- Mothur and Deblur consistent across sequencing runs  
- qiime open ref, closed ref, and de novo richness dependent on both quality and library size  
    

<!-- Excluding for now not sure contributes to narrative -->
<!-- * Prevalence (Fig. \@ref(fig:prevPlot))   -->
<!--     - DADA2 slope starts later than other pipelines   -->
<!--     - mothur starts to plateu ...  -->
<!--     - qiime de-novo, open and closed ref hump?   -->
<!-- Species abundance curves are fundamentally different between pipelines, indicating that the features generated using represent different biological units and therefore should be interpreted as such (Fig. \@ref(fig:abuDistPlot)) -->


